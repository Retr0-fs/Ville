<!DOCTYPE html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <title>Ville THREE.js Simplifiée</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <!-- Inclusion de THREE.js depuis cdnjs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Inclusion d'OrbitControls (version non-module) -->
    <script src="https://threejs.org/examples/js/controls/OrbitControls.js"></script>
    <script>
      console.log("Initialisation de la scène THREE.js");

      // Création de la scène
      var scene = new THREE.Scene();
      scene.background = new THREE.Color(0x87ceeb); // ciel bleu

      // Configuration de la caméra
      var camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000
      );
      camera.position.set(40, 30, 40);
      camera.lookAt(0, 0, 0);

      // Création du renderer
      var renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);

      // Création du sol
      var groundGeometry = new THREE.PlaneGeometry(100, 100);
      var groundMaterial = new THREE.MeshLambertMaterial({ color: 0x228B22 });
      var ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      scene.add(ground);

      // Ajout des éclairages
      var ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
      scene.add(ambientLight);

      var directionalLight = new THREE.DirectionalLight(0xffffff, 1);
      directionalLight.position.set(50, 50, 0);
      scene.add(directionalLight);

      // Paramètres de la grille
      var gridSize = 6;       // cases allant de -6 à 6
      var spacing = 7;        // espacement entre cases
      var roadColor = 0x404040;
      var roadWidth = 3;      // largeur des routes
      var buildingWidth = 2;  // largeur des bâtiments
      var buildingDepth = 2;  // profondeur des bâtiments

      // Fonction : renvoie true si la case correspond à une route (toutes les 3ème cases)
      function isRoad(index) {
        return ((index + gridSize) % 3 === 0);
      }

      // Création des routes verticales
      for (var i = -gridSize; i <= gridSize; i++) {
        if (isRoad(i)) {
          var roadGeom = new THREE.PlaneGeometry(roadWidth, 120);
          var roadMat = new THREE.MeshLambertMaterial({ color: roadColor });
          var roadMesh = new THREE.Mesh(roadGeom, roadMat);
          roadMesh.rotation.x = -Math.PI / 2;
          roadMesh.position.set(i * spacing, 0.1, 0);
          scene.add(roadMesh);
        }
      }

      // Création des routes horizontales
      for (var j = -gridSize; j <= gridSize; j++) {
        if (isRoad(j)) {
          var roadGeom = new THREE.PlaneGeometry(120, roadWidth);
          var roadMat = new THREE.MeshLambertMaterial({ color: roadColor });
          var roadMesh = new THREE.Mesh(roadGeom, roadMat);
          roadMesh.rotation.x = -Math.PI / 2;
          roadMesh.position.set(0, 0.1, j * spacing);
          scene.add(roadMesh);
        }
      }

      // Fonction pour créer un bâtiment
      function createBuilding(x, z) {
        var height = Math.random() * 5 + 3; // hauteur entre 3 et 8
        var geometry = new THREE.BoxGeometry(buildingWidth, height, buildingDepth);
        var material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
        var building = new THREE.Mesh(geometry, material);
        building.position.set(x, height / 2, z);
        scene.add(building);
      }

      // Placement des bâtiments sur les cases non réservées aux routes
      for (var i = -gridSize; i <= gridSize; i++) {
        for (var j = -gridSize; j <= gridSize; j++) {
          if (!isRoad(i) && !isRoad(j)) {
            var x = i * spacing + (Math.random() - 0.5);
            var z = j * spacing + (Math.random() - 0.5);
            createBuilding(x, z);
          }
        }
      }

      // Création de deux voitures animées sur les routes
      var cars = [];
      var carGeometry = new THREE.BoxGeometry(1, 0.5, 2);
      var carMaterial = new THREE.MeshLambertMaterial({ color: 0xff0000 });

      // Voiture évoluant sur une route verticale
      var verticalRoadIndex = -2;
      var carVertical = new THREE.Mesh(carGeometry, carMaterial);
      carVertical.position.set(verticalRoadIndex * spacing, 0.25, -60);
      scene.add(carVertical);
      cars.push({ mesh: carVertical, axis: "z", min: -60, max: 60, speed: 0.3 });

      // Voiture évoluant sur une route horizontale
      var horizontalRoadIndex = -2;
      var carHorizontal = new THREE.Mesh(carGeometry, carMaterial);
      carHorizontal.rotation.y = Math.PI / 2;
      carHorizontal.position.set(-60, 0.25, horizontalRoadIndex * spacing);
      scene.add(carHorizontal);
      cars.push({ mesh: carHorizontal, axis: "x", min: -60, max: 60, speed: 0.3 });

      // Mise en place d'OrbitControls pour contrôler la caméra
      var controls = new THREE.OrbitControls(camera, renderer.domElement);
      controls.enableDamping = true;
      controls.autoRotate = true;
      controls.autoRotateSpeed = 0.5;

      // Boucle d'animation
      function animate() {
        requestAnimationFrame(animate);
        controls.update();

        cars.forEach(function(car) {
          if (car.axis === "z") {
            car.mesh.position.z += car.speed;
            if (car.mesh.position.z > car.max) {
              car.mesh.position.z = car.min;
            }
          } else if (car.axis === "x") {
            car.mesh.position.x += car.speed;
            if (car.mesh.position.x > car.max) {
              car.mesh.position.x = car.min;
            }
          }
        });

        renderer.render(scene, camera);
      }
      animate();

      // Ajustement en cas de redimensionnement de la fenêtre
      window.addEventListener("resize", function () {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      console.log("Chargement terminé – vérifie la console pour d'éventuelles erreurs.");
    </script>
  </body>
</html>
